var documenterSearchIndex = {"docs":
[{"location":"#QuartoTools.jl","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"","category":"section"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Utilities for working with Quarto notebooks in Julia","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"This package provides several utilities that can be used in conjuction with Quarto notebooks when using the engine: julia setting, which executes your notebook code with QuartoNotebookRunner.jl.","category":"page"},{"location":"#\"Expandables\"","page":"QuartoTools.jl","title":"\"Expandables\"","text":"","category":"section"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"QuartoNotebookRunner.jl has a special feature called cell expansion. It allows you to have a single code cell that outputs what looks like multiple code cells and their outputs to Quarto.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"What can you use this feature for?","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Quarto has many advanced options which allow you to create richer output, for example tabsets which can group several separate sections of a quarto notebook into selectable tabs. These features are controlled with markdown annotations, for example, a tabset follows this structure:","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"::: {.panel-tabset}\n\n## Tab 1\n\nContent of tab 1\n\n## Tab 2\n\nContent of tab 2\n\n... possibly more tabs ...\n\n:::","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"As you can see, the tabset begins and ends with a pandoc ::: div fence and consists of sections demarcated by markdown headings. This mechanism has two drawbacks for the user:","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"It can be tricky to get the syntax right, especially with multiple nested ::: fences that need to be closed correctly. (This also applies when you generate markdown programmatically by printing out snippets in loops and using the output: asis cell option.)\nIt is static. Each tab has to be written into the source markdown explicitly, so you cannot easily create a tabset with a dynamic number of tabs. For example, a tabset with one plot per tab where the number of plots depends on runtime information and therefore is not known in advance.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Cell expansion can solve both of these problems. It relies on a function called QuartoNotebookWorker.expand, which is defined within the notebook worker process for every notebook that you execute.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"When a notebook cell returns a Julia value from a cell, such that it is displayed but Quarto, the expand function will first be called on that value. By default this returns nothing and so we just display the original value. But if an expand method is defined for that type, then it should return a Vector{QuartoNotebookWorker.Cell} object which is then evaluated as if they were real cells. This feature is recursive, so Cells can themselves return more vectors of Cells.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Thus we can use these cells to build the structures Quarto expects programmatically, instead of having to hardcode them into the notebook.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"For example, a tabset with plots could be generated by expanding into:","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"a cell with markdown output ::: {.panel-tabset}\na cell with markdown output ## Tab 1\na cell with a plot output, for example a Makie.Figure\nmore headings and plots\na cell with markdown output :::","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"note: Note\nCell expansion is not code generation. We do not generate and evaluate arbitrary code. Instead, we create objects describing code cells together with their outputs which is easier to reason about and more composable.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Each QuartoNotebookWorker.Cell has three fields:","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"thunk stores a function which returns the fake cell's output value when run. This value is treated as any other code cell output value, so it may be of any type that the display system can handle, and it may even be expandable itself (allowing for recursive expansion).\ncode may hold a string which will be rendered as the code of the fake cell (this code is not run).\noptions is a dictionary of quarto cell options, for example \"echo\" => false to hide the source code section.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"QuartoTools defines a set of helper objects that can serve as building blocks that can be composed further. For example, a Tabset may contain multiple Divs, each describing a two-column layout which is populated with two plots.","category":"page"},{"location":"#Caching","page":"QuartoTools.jl","title":"Caching","text":"","category":"section"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"QuartoTools provides a caching mechanism that can be used to save the results of expensive function calls in your notebook cells. Once loaded into a notebook via a cell containing import QuartoTools you can annotate any subsequent cell with the julia.cache.enabled key as follows:","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"---\nengine: julia\n---\n\n```{julia}\nimport QuartoTools\n```\n\n```{julia}\n#| julia:\n#|   cache:\n#|     enabled: true\nresult = expensive_func(arg)\n```","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"The first time that expensive_func is called with any specific arg value the result will be saved to disk using Serialization. Subsequent calls with the same arg value will return the cached result rather than re-running expensive_func. This can be useful for long-running computations that slow down the rendering of your notebook.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Avoid using the feature on cells that only take a few seconds that run, since the overhead of saving and loading cached results can be larger than the time saved. If you have a particularly complex cell that contains some fast calls and some slow ones, try to factor them out into separate cells and only run the caching on the slow ones.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"The cache for each notebook is stored alongside it in a folder called .cache. Removing this folder will clear the cache for the notebook. Do not commit the contents of this folder to version control.","category":"page"},{"location":"#Serialization","page":"QuartoTools.jl","title":"Serialization","text":"","category":"section"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"When working with serialized data in Quarto notebooks users must use the QuartoTools.serialize and QuartoTools.deserialize functions provided by the QuartoTools package rather than the Serialization package. This is due to the differences in the behaviour of code evaluation between the Julia REPL and that of Quarto. These two functions are drop-in replacements for those provided by Serialization and fall back on the implementation provided by it when not run in a Quarto notebook. This means that simply replacing using Serialization with using QuartoTools should be sufficient to allow for transparent serialization and deserialization between notebooks, batch scripts, and the REPL.","category":"page"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Note that if both QuartoTools and Serialization are imported with using in the same session then the functions serialize and deserialize will need to be prefixed with their package name due to the name collisions between the two packages. Typically users should only need to import QuartoTools.","category":"page"},{"location":"#Docstrings","page":"QuartoTools.jl","title":"Docstrings","text":"","category":"section"},{"location":"","page":"QuartoTools.jl","title":"QuartoTools.jl","text":"Modules = [QuartoTools]","category":"page"},{"location":"#QuartoTools.Cell","page":"QuartoTools.jl","title":"QuartoTools.Cell","text":"struct Cell\n\nCell(content::Function; code = nothing, options = Dict{String,Any}(), lazy = true)\nCell(content; code = nothing, options = Dict{String,Any}(), lazy = false)\n\nThe most basic expandable object, representing a single code cell with output.\n\nIf code === nothing, the code cell will be hidden by default using the quarto option echo: false. Note that code is never evaluated, merely displayed in code cell style.  Only content determines the actual cell output.\n\nAll options are written into the YAML options header of the code cell, this way you can use any cell option commonly available in code cells for your generated cells. For example, options = Dict(\"echo\" => false) will splice #| echo: false into the code cell's options header.\n\nIf lazy === true, the output will be treated as a thunk, which has to be executed by QuartoNotebookRunner to get the actual output object that should have display called on it. Accordingly, you will get an error if the output object is not a Base.Callable. If lazy === false, the output will be used as the actual output object directly by QuartoNotebookRunner. As an example, if you generate a hundred plot output cells, it is probably better to generate the plots using lazy functions, rather than storing all of them in memory at once. The lazy option is set to true by default when a Function is passed to the convenience constructor, and to false otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#QuartoTools.Div","page":"QuartoTools.jl","title":"QuartoTools.Div","text":"struct Div\n\nDiv(children::Vector; id=[], class=[], attributes=Dict())\nDiv(child; kwargs...)\n\nConstruct a Div which is an expandable that wraps its child cells with two markdown fence cells to create a pandoc div using ::: as the fence delimiters. Div optionally allows to specify one or more ids, classes and key-value attributes for the div.\n\nid and class should each be either one AbstractString or an AbstractVector of those. attributes should be convertible to a Dict{String,String}.\n\nExamples\n\nDiv(Cell(123))\nDiv(\n    [Cell(123), Cell(\"ABC\")];\n    id = \"someid\",\n    class = [\"classA\", \"classB\"],\n    attributes = Dict(\"somekey\" => \"somevalue\"),\n)\n\n\n\n\n\n","category":"type"},{"location":"#QuartoTools.Expand","page":"QuartoTools.jl","title":"QuartoTools.Expand","text":"struct Expand\n\nExpand(expandables::AbstractVector)\n\nConstruct an Expand which is an expandable that wraps a vector of other expandable. This allows to create multiple output cells using a single return value in an expanded quarto cell.\n\nExample\n\nExpand([Cell(123), Cell(\"ABC\")])\n\n\n\n\n\n","category":"type"},{"location":"#QuartoTools.Tabset","page":"QuartoTools.jl","title":"QuartoTools.Tabset","text":"struct Tabset\n\nTabset(pairs; group = nothing)\n\nConstruct a Tabset which is an expandable that expands into multiple cells representing one quarto tabset (using the ::: {.panel-tabset} syntax).\n\npairs should be convertible to a Vector{Pair{String,Any}}. Each Pair in pairs describes one tab in the tabset. The first element in the pair is its title and the second element its content.\n\nYou can optionally pass some group id as a String to the group keyword which enables quarto's grouped tabset feature where multiple tabsets with the same id are switched together.\n\nExample\n\nTabset([\n    \"Tab 1\" => Cell(123),\n    \"Tab 2\" => Cell(\"ABC\")\n])\n\n\n\n\n\n","category":"type"},{"location":"#QuartoTools.MarkdownCell-Tuple{String}","page":"QuartoTools.jl","title":"QuartoTools.MarkdownCell","text":"MarkdownCell(s::String)\n\nA convenience function which constructs a Cell that will be rendered by quarto with the output: asis option. The string s will be interpreted as markdown syntax, so the output will look as if s had been written into the quarto notebook's markdown source directly.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.cacheable-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.cacheable","text":"cacheable(f) -> Bool\n\nDetermine if a function is cacheable. By default all functions are cacheable. Use this function to override that behaviour, for example to make Base.read uncacheable:\n\nQuartoTools.cacheable(::typeof(Base.read)) = false\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.content_hash-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.content_hash","text":"content_hash(object)\n\nCompute a content hash for the given object. This should result in hashes that match between different instances of identical objects. Used for cache keys.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.deconstruct-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.deconstruct","text":"deconstruct(value::T) -> S\n\nAn extension function for turning values of type T into a type S such that they can be serialized properly.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.deserialize","page":"QuartoTools.jl","title":"QuartoTools.deserialize","text":"deserialize(s::IO)\ndeserialize(filename::AbstractString)\n\nDeserialize a value from the given IO stream or file using Julia's built-in serialization while correctly handling differences in \"root\" evaluation module between the REPL and Quarto notebooks.\n\n\n\n\n\n","category":"function"},{"location":"#QuartoTools.reading_time-Tuple{}","page":"QuartoTools.jl","title":"QuartoTools.reading_time","text":"reading_time(;\n    words_per_minute::Integer=238,\n    progress_bar::Bool=true,\n    progress_bar_color::String=\"#0066cc\",\n    reading_time_template::Function\n)\n\nAdd an estimated reading time to the top of the rendered HTML Quarto document.\n\nWhen progress_bar is true then also add a thin progress bar to the top edge of the document that shows the current scroll position. progress_bar_color can be used to customize the color of the progress bar.\n\nreading_time_template is a function that lets you customize the HTML that is generated for the reading time message. It takes a single argument minutes which is the JavaScript interpolation variable that will be replaced with the actual minutes in the browser. It is not the actual number of minutes.\n\nThis function has no effect when used in non-HTML output formats.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.reconstruct-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.reconstruct","text":"reconstruct(value::S) -> T\n\nAn extension function for turning values of type S back into a type T after they have been deserialized.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.serialize","page":"QuartoTools.jl","title":"QuartoTools.serialize","text":"serialize(s::IO, x)\nserialize(filename::AbstractString, x)\n\nSerialize x to the given IO stream or file using Julia's built-in serialization while correctly handling differences in \"root\" evaluation module between the REPL and Quarto notebooks.\n\n\n\n\n\n","category":"function"},{"location":"#QuartoTools.toggle_cache-Tuple{}","page":"QuartoTools.jl","title":"QuartoTools.toggle_cache","text":"toggle_cache()\n\nSwitch caching of function calls in the REPL on/off.\n\n\n\n\n\n","category":"method"},{"location":"#QuartoTools.@cache-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.@cache","text":"@cache func(args...; kws...)\n\nCache the result of a function call with the given arguments and keyword arguments.\n\nThe caching key is based on:\n\nThe full VERSION of Julia.\nThe Function being called.\nThe Module in which the function is called.\nThe file in which the function is called.\nThe active Project.toml.\nThe argument values and keyword argument values passed to the function.\n\nThe cache is stored in a .cache directory in the same directory as the file in which the function is called. Deleting this directory will clear the cache.\n\n\n\n\n\n","category":"macro"},{"location":"#QuartoTools.@nc_cmd-Tuple{Any}","page":"QuartoTools.jl","title":"QuartoTools.@nc_cmd","text":"nc`variable_name` = func(args...)\n\nMark the given variable as non-cachable. This means that assigning to this variable from a function call will not cache the function call. This is equivalent to using the julia.cache.ignored array in cell options or notebook frontmatter in a Quarto notebook.\n\n\n\n\n\n","category":"macro"}]
}
