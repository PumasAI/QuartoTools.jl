# QuartoTools.jl

*Utilities for working with Quarto notebooks in Julia*

This package provides several utilities that can be used in conjuction with
Quarto notebooks when using the `engine: julia` setting, which executes your
notebook code with
[QuartoNotebookRunner.jl](https://github.com/PumasAI/QuartoNotebookRunner.jl).

## "Expandables"

`QuartoNotebookRunner.jl` has a special feature called cell expansion. It
allows you to have a single code cell that outputs what looks like multiple
code cells and their outputs to Quarto.

*What can you use this feature for?*

Quarto has many advanced options which allow you to create richer output, for
example [tabsets](https://quarto.org/docs/interactive/layout.html#tabset-panel)
which can group several separate sections of a quarto notebook into selectable
tabs. These features are controlled with markdown annotations, for example, a
tabset follows this structure:

````qmd
::: {.panel-tabset}

## Tab 1

Content of tab 1

## Tab 2

Content of tab 2

... possibly more tabs ...

:::
````

As you can see, the tabset begins and ends with a pandoc `:::` div fence and
consists of sections demarcated by markdown headings. This mechanism has two
drawbacks for the user:

  - It can be tricky to get the syntax right, especially with multiple nested `:::` fences that need to be closed correctly. (This also applies when you generate markdown programmatically by printing out snippets in loops and using the `output: asis` cell option.)
  - It is static. Each tab has to be written into the source markdown explicitly, so you cannot easily create a tabset with a dynamic number of tabs. For example, a tabset with one plot per tab where the number of plots depends on runtime information and therefore is not known in advance.

Cell expansion can solve both of these problems. It relies on a function called
`QuartoNotebookWorker.expand`, which is defined within the notebook worker
process for every notebook that you execute.

When a notebook cell returns a Julia value from a cell, such that it is
displayed but Quarto, the `expand` function will first be called on that value.
By default this returns `nothing` and so we just display the original value.
But if an `expand` method is defined for that type, then it should return a
`Vector{QuartoNotebookWorker.Cell}` object which is then evaluated as if they
were real cells. This feature is recursive, so `Cell`s can themselves return
more vectors of `Cell`s.

Thus we can use these cells to build the structures Quarto expects
programmatically, instead of having to hardcode them into the notebook.

For example, a tabset with plots could be generated by expanding into:

  - a cell with markdown output `::: {.panel-tabset}`
  - a cell with markdown output `## Tab 1`
  - a cell with a plot output, for example a `Makie.Figure`
  - more headings and plots
  - a cell with markdown output `:::`

!!! note

    Cell expansion is not code generation. We do not generate and evaluate
    arbitrary code. Instead, we create objects describing code cells together with
    their outputs which is easier to reason about and more composable.

Each `QuartoNotebookWorker.Cell` has three fields:

  - `thunk` stores a function which returns the fake cell's output value when run. This value is treated as any other code cell output value, so it may be of any type that the display system can handle, and it may even be expandable itself (allowing for recursive expansion).
  - `code` may hold a string which will be rendered as the code of the fake cell (this code is not run).
  - `options` is a dictionary of quarto cell options, for example `"echo" => false` to hide the source code section.

`QuartoTools` defines a set of helper objects that can serve as building blocks
that can be composed further. For example, a [`Tabset`](@ref QuartoTools.Tabset)
may contain multiple [`Div`](@ref QuartoTools.Div)s, each describing a
two-column layout which is populated with two plots.

## Caching

`QuartoTools` provides a caching mechanism that can be used to save the results
of expensive function calls in your notebook cells. Once loaded into a notebook
via a cell containing `import QuartoTools` you can annotate any subsequent cell
with the `julia.cache.enabled` key as follows:

````qmd
---
engine: julia
---

```{julia}
import QuartoTools
```

```{julia}
#| julia:
#|   cache:
#|     enabled: true
result = expensive_func(arg)
```
````

The first time that `expensive_func` is called with any specific `arg` value
the result will be saved to disk using [Serialization](@ref). Subsequent calls
with the same `arg` value will return the cached result rather than re-running
`expensive_func`. This can be useful for long-running computations that slow
down the rendering of your notebook.

Avoid using the feature on cells that only take a few seconds that run, since
the overhead of saving and loading cached results can be larger than the time
saved. If you have a particularly complex cell that contains some fast calls
and some slow ones, try to factor them out into separate cells and only run the
caching on the slow ones.

The cache for each notebook is stored alongside it in a folder called `.cache`.
Removing this folder will clear the cache for the notebook. Do not commit the
contents of this folder to version control.

## Serialization

When working with serialized data in Quarto notebooks users must use the
[`QuartoTools.serialize`](@ref) and [`QuartoTools.deserialize`](@ref) functions
provided by the `QuartoTools` package rather than the `Serialization` package.
This is due to the differences in the behaviour of code evaluation between the
Julia REPL and that of Quarto. These two functions are drop-in replacements for
those provided by `Serialization` and fall back on the implementation provided
by it when not run in a Quarto notebook. This means that simply replacing
`using Serialization` with `using QuartoTools` should be sufficient to allow
for transparent serialization and deserialization between notebooks, batch
scripts, and the REPL.

Note that if both `QuartoTools` and `Serialization` are imported with `using`
in the same session then the functions `serialize` and `deserialize` will need
to be prefixed with their package name due to the name collisions between the
two packages. Typically users should only need to import `QuartoTools`.

## Docstrings

```@autodocs
Modules = [QuartoTools]
```
